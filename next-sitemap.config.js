/* eslint-disable no-undef */
/** @type {import('next-sitemap').IConfig} */

// Required imports
const fs = require('fs');
const path = require('path');
const { globSync } = require('glob'); // Using globSync for simplicity in this config file
const matter = require('gray-matter');

// Helper function to get blog MDX data
const getBlogMdxData = () => {
  const contentDir = path.join(process.cwd(), 'content');
  // Glob pattern to find index.mdx files in subdirectories of content
  // e.g., content/some-slug/index.mdx, content/category/other-slug/index.mdx
  const files = globSync(path.join(contentDir, '**/index.mdx'));

  return files.map(file => {
    const fileContents = fs.readFileSync(file, 'utf8');
    const { data: frontmatter } = matter(fileContents);

    // Determine slug: assumes the directory name directly under /content/ or /content/<category>/ is the slug.
    // This might need adjustment based on the exact URL structure and directory depth for slugs.
    // Example: 'content/my-blog-post/index.mdx' -> slug = 'my-blog-post'
    // Example: 'content/category/my-blog-post/index.mdx' -> slug = 'my-blog-post' (if category is not part of slug)
    // For this implementation, let's assume the parent directory name is the slug.
    const slug = path.basename(path.dirname(file));

    // IMPORTANT: Adjust '/blog/' prefix if actual routing is different.
    // This prefix determines the URL structure in the sitemap.
    const loc = `/blog/${slug}`;

    let lastmod = frontmatter.updatedAt || frontmatter.publishedAt;
    if (lastmod) {
      lastmod = new Date(lastmod).toISOString();
    } else {
      // Fallback if no date is in frontmatter; consider logging this during build
      lastmod = new Date().toISOString();
    }

    return {
      loc,
      lastmod,
      changefreq: 'weekly', // Default for blog posts
      priority: 0.8,      // Default for blog posts
    };
  }).filter(post => frontmatter.isPublished !== false); // Only include published posts if frontmatter exists
};

module.exports = {
  siteUrl: "https://www.hushh.ai",
  generateRobotsTxt: true, // Consider setting to false if public/robots.txt is manually maintained and preferred
  robotsTxtOptions: {
    policies: [
      {
        userAgent: "*",
        allow: "/",
        disallow: [
          "/api/*",
          "/_next/*",
          "/*?q=*"
        ],
      },
    ],
    additionalSitemaps: [
      "https://www.hushh.ai/server-sitemap.xml", // This points to sitemap generated by Next.js for dynamic pages if any
    ],
  },
  // Default priority and changefreq for pages discovered by next-sitemap (e.g., in pages/ or app/ directories)
  priority: 0.7,
  changefreq: "daily", // Default changefreq, will be overridden by transform for specific paths
  sitemapSize: 7000,
  generateIndexSitemap: true, // Recommended for large sites, generates sitemap.xml as an index
  autoLastmod: true, // Automatically set lastmod to current date for discovered pages if not specified

  // Dynamically add blog post paths
  additionalPaths: async (config) => {
    const blogData = getBlogMdxData();
    // The objects returned by getBlogMdxData already match the expected structure
    // { loc: string, lastmod?: string, changefreq?: IConfig['changefreq'], priority?: number }
    return blogData;
  },

  // Transform function to customize properties of each sitemap entry
  // This function will be called for paths from `additionalPaths` as well as those discovered by next-sitemap
  transform: async (config, path) => {
    // `path` is the 'loc' string.
    // `config` is the global config object from next-sitemap.

    // Default values from the global config or from what additionalPaths might have set
    // For paths from additionalPaths, they might already have priority, changefreq, lastmod.
    // We need to decide if we override them here or respect them.
    // The object returned by additionalPaths already sets these, so we can choose to respect them.

    const existingPathData = (await config.additionalPaths(config)).find(p => p.loc === path);

    if (existingPathData && existingPathData.lastmod) {
      // If path came from additionalPaths and had a lastmod, respect it.
      // And respect its priority and changefreq too.
      return {
        loc: path,
        changefreq: existingPathData.changefreq || 'weekly',
        priority: existingPathData.priority || 0.8,
        lastmod: existingPathData.lastmod,
      };
    }
    
    // Default priority and changefreq for other pages (not from additionalPaths or needing override)
    let priority = config.priority;
    let changefreq = config.changefreq;

    // Custom priority & changefreq for specific important pages (non-blog)
    if (path === '/') {
      priority = 1.0;
      changefreq = 'daily';
    } else if (path === '/products/hushh-wallet-app') { // These are old, likely 404, but keeping logic for example
      priority = 0.9;
    } else if (path === '/products/hushh-button') {
      priority = 0.9;
    } else if (path === '/products/browser-companion') {
      priority = 0.9;
    } else if (path === '/products/hushh-vibe-search') {
      priority = 0.9;
    } else if (path === '/developerApi') {
      priority = 0.9;
    } else if (path === '/about') { // Assuming /about exists or will exist
      priority = 0.8;
    } else if (path === '/contact-us') { // Assuming /contact-us exists or will exist
      priority = 0.8;
    }
    // Add other specific page rules if needed

    return {
      loc: path,
      changefreq,
      priority,
      lastmod: config.autoLastmod ? new Date().toISOString() : undefined,
    };
  },
};
